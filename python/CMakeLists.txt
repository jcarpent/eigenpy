#
# Copyright (c) 2014-2019 CNRS
# Copyright (c) 2018-2019 INRIA
#

MACRO(SYMLINK_AND_INSTALL_HEADERS HEADERS SUBPATH)
  FOREACH(header ${HEADERS})
    GET_FILENAME_COMPONENT(headerName ${header} NAME)
    GET_FILENAME_COMPONENT(headerPath ${header} PATH)
    EXECUTE_PROCESS(COMMAND ${CMAKE_COMMAND} -E ${LINK}
      ${CMAKE_CURRENT_SOURCE_DIR}/${header}
      ${${PROJECT_NAME}_BINARY_DIR}/include/${PROJECT_NAME}/${SUBPATH}/${header})

    INSTALL(FILES ${CMAKE_CURRENT_SOURCE_DIR}/${header}
      DESTINATION ${CMAKE_INSTALL_PREFIX}/include/${PROJECT_NAME}/${SUBPATH}/${headerPath}
            PERMISSIONS OWNER_READ GROUP_READ WORLD_READ OWNER_WRITE)
  ENDFOREACH(header)
ENDMACRO(SYMLINK_AND_INSTALL_HEADERS HEADERS SUBPATH)

# --- LIBRARY --- #
SET(PYWRAP ${PROJECT_NAME}_pywrap) 
SET(PYWRAP ${PYWRAP} PARENT_SCOPE)

MAKE_DIRECTORY("${${PROJECT_NAME}_BINARY_DIR}/python/${PROJECT_NAME}")

ADD_LIBRARY(${PYWRAP} SHARED main.cpp)
TARGET_LINK_LIBRARIES(${PYWRAP} PUBLIC ${PROJECT_NAME}) 
# BOOST_PYTHON_MEMBER_FUNCTION_OVERLOADS spews conversion warnings from int to long unsigned int.
# Unfortunately, using literals does not work in a macro. As such, this turns them off for the entire wrapper:
IF(NOT WIN32)
  TARGET_COMPILE_OPTIONS(${PYWRAP} PRIVATE "-Wno-conversion")
ENDIF()
#IF(BUILD_WITH_COMMIT_VERSION)
#  TAG_LIBRARY_VERSION(${PYWRAP})
#ENDIF(BUILD_WITH_COMMIT_VERSION)
IF(DEFINED EIGENPY_SITELIB_ROOT AND EIGENPY_SITELIB_ROOT)
  SET(${PYWRAP}_INSTALL_DIR ${EIGENPY_SITELIB_ROOT}/${PYTHON_SITELIB})
ELSE()
  SET(${PYWRAP}_INSTALL_DIR ${CMAKE_INSTALL_PREFIX}/${PYTHON_SITELIB})
ENDIF()

SET_TARGET_PROPERTIES(${PYWRAP} PROPERTIES SUFFIX ${PYTHON_EXT_SUFFIX})

SET_TARGET_PROPERTIES(${PYWRAP} PROPERTIES
  LIBRARY_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/python/${PROJECT_NAME}")

SET_TARGET_PROPERTIES(${PYWRAP} PROPERTIES PREFIX "")
SET_TARGET_PROPERTIES(${PYWRAP} PROPERTIES OUTPUT_NAME "${PROJECT_NAME}")

INSTALL(TARGETS ${PYWRAP} DESTINATION ${${PYWRAP}_INSTALL_DIR})

## --- INSTALL SCRIPTS 
#SET(PYTHON_FILES
#  __init__.py
#  )
#
#FOREACH(python ${PYTHON_FILES})
#  GET_FILENAME_COMPONENT(pythonFile ${python} NAME)
#  EXECUTE_PROCESS(COMMAND ${CMAKE_COMMAND} -E ${LINK}
#    ${${PROJECT_NAME}_SOURCE_DIR}/python/scripts/${python}
#    ${${PROJECT_NAME}_BINARY_DIR}/python/${PROJECT_NAME}/${pythonFile})
#    
#  # Generate pyc file
#  EXECUTE_PROCESS(COMMAND
#    ${PYTHON_EXECUTABLE} -m py_compile
#    ${${PROJECT_NAME}_BINARY_DIR}/python/${PROJECT_NAME}/${pythonFile})
#  # Tag pyc file as generated.
#  SET_SOURCE_FILES_PROPERTIES(
#    "${${PROJECT_NAME}_BINARY_DIR}/python/${PROJECT_NAME}/${pythonFile}c"
#    PROPERTIES GENERATED TRUE)
#    
#  # Clean generated files.
#  SET_PROPERTY(
#    DIRECTORY APPEND PROPERTY
#    ADDITIONAL_MAKE_CLEAN_FILES
#    "${${PROJECT_NAME}_BINARY_DIR}/python/${PROJECT_NAME}/${pythonFile}c")
#    
#  INSTALL(FILES
#    "${${PROJECT_NAME}_SOURCE_DIR}/python/scripts/${python}"
#    "${${PROJECT_NAME}_BINARY_DIR}/python/${PROJECT_NAME}/${pythonFile}c"
#    DESTINATION ${${PYWRAP}_INSTALL_DIR})
#ENDFOREACH(python)

